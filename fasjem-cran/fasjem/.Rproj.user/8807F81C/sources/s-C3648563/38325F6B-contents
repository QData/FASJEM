.norm_vec <- function(x)
  sqrt(sum(x ^ 2))
.norm_infty <- function(x)
  max(abs(x))

.f1 <- function(x, ga) {
  result = sign(x) * pmax(abs(x) - ga, 0)
  return(result)
}

.g1 <- function(x, a, lambda) {
  result = pmax(pmin(x - a, -lambda), lambda) + a
  return(result)
}

.f2 <- function(x, ga) {
  result = x * array(pmax(1 - ga / apply(x, c(1, 2), .norm_vec), 0), dim(x))
  return(result)
}

.g2 <- function(x, a, lambda) {
  result = array(pmax(lambda / apply(x - a, c(1, 2), .norm_vec), 1), dim(x)) * (x - a) + a
  return(result)
}

.f2_infty <- function(x, ga) {
  result = x * array(pmax(1 - ga / apply(x, c(1, 2), .norm_infty), 0), dim(x))
  return(result)
}

.g2_infty <- function(x, a, lambda) {
  result = array(pmax(lambda / apply(x - a, c(1, 2), .norm_infty), 1), dim(x)) * (x - a) + a
  return(result)
}

.fasjem_g <- function(a, lambda, epsilon, gamma, rho, iterMax) {
  x  = .f1(a, (4 * lambda * gamma))
  x1 = x
  x2 = x
  x3 = x
  x4 = x
  for (i in 1:iterMax) {
    p1 = .f1(x1, (4 * lambda * gamma))
    p2 = .g1(x2, a, (4 * lambda * gamma * epsilon))
    p3 = .f2(x3, lambda)
    p4 = .g2(x4, a, (epsilon * lambda))
    p  = (p1 + p2 + p3 + p4) / 4
    x1 = x1 + (p * 2 - p1 - x1) * rho
    x2 = x2 + (p * 2 - p2 - x2) * rho
    x3 = x3 + (p * 2 - p3 - x3) * rho
    x4 = x4 + (p * 2 - p4 - x4) * rho
    x  = x  + (p - x) * rho
  }
  x = .f1(x, (4 * lambda * gamma))
  return(x)
}

.fasjem_i <- function(a, lambda, epsilon, gamma, rho, iterMax) {
  x  = .f1(a, (4 * lambda * gamma))
  x1 = x
  x2 = x
  x3 = x
  x4 = x
  for (i in 1:iterMax) {
    p1 = .f1(x1, (4 * lambda * gamma))
    p2 = .g1(x2, a, (4 * lambda * gamma * epsilon))
    p3 = .f2_infty(x3, lambda)
    p4 = .g2_infty(x4, a, (epsilon * lambda))
    p  = (p1 + p2 + p3 + p4) / 4
    x1 = x1 + (p * 2 - p1 - x1) * rho
    x2 = x2 + (p * 2 - p2 - x2) * rho
    x3 = x3 + (p * 2 - p3 - x3) * rho
    x4 = x4 + (p * 2 - p4 - x4) * rho
    x  = x  + (p - x) * rho
  }
  x = .f1(x, (4 * lambda * gamma))
  return(x)
}

.EEGM <- function(covMatrix, lambda) {
  result = sign(covMatrix) * pmax(abs(covMatrix) - lambda, 0)
  result
}

.backwardMap <- function(covMatrix) {
  niuList = 0.001 * (1:1000)
  bestDet = det(.EEGM(covMatrix, 0.001))
  bestniu = 0.001
  for (i in 1:1000) {
    if (bestDet < det(.EEGM(covMatrix, niuList[i]))) {
      bestDet = det(.EEGM(covMatrix, niuList[i]))
      bestniu = niuList[i]
    }
  }
  return(solve(.EEGM(covMatrix, bestniu)))
}

fasjem <-
  function(X,
           method = "fasjem-g",
           lambda = 0.5,
           epsilon = 0.1,
           gamma = 0.1,
           rho = 0.05,
           iterMax = 10) {
    if (is.data.frame(X[[1]])) {
      for (i in 1:(length(X))) {
        X[[i]] = as.matrix(X[[i]])
      }
    }

    #get number of tasks
    N = length(X)
    #get the cov/cor matrices
    if (isSymmetric(X[[1]]) == FALSE) {
      for (i in 1:N) {
        X[[i]] = cov(X[[i]])
      }
    }

    tmp = array(0, dim = c(dim(X[[1]])[1], dim(X[[1]])[2], length(X)))
    for (i in 1:length(X)) {
      tmp[, , i] = X[[i]]
    }
    if (!isSymmetric(X[[1]])) {
      tmp = array(apply(tmp, 3, cov), dim = c(ncol(X[[i]]), ncol(X[[i]]), length(X)))
    }

    tmp = array(apply(tmp, 3, .backwardMap), dim = c(ncol(X[[i]]), ncol(X[[i]]), length(X)))
    if (method == "fasjem-g") {
      tmp = .fasjem_g(tmp, lambda, epsilon, gamma, rho, iterMax)
    }
    if (method == "fasjem-i") {
      tmp = .fasjem_i(tmp, lambda, epsilon, gamma, rho, iterMax)
    }
    result = list()
    for (i in 1:dim(tmp)[3]) {
      result[[i]] = tmp[, , i]
    }
    class(result) = "fasjem"
    return(result)
  }


returngraph.fasjem <-
  function(fasjemresult,
           type = "task",
           neighbouroption = "task",
           subID = NULL,
           index = NULL) {
    .env = "environment: namespace:fasjem"
    adj = .make.adj.matrix(fasjemresult)
    diag(adj) = 0
    gadj = graph.adjacency(adj, mode = "upper", weighted = TRUE)

    if (!is.null(E(gadj)$weight)) {
      E(gadj)$color = E(gadj)$weight
    }

    K = length(fasjemresult)
    if (type == "share") {
      ### ignore subID and index
      gadj = subgraph.edges(gadj, which(E(gadj)$weight == K + 1), delete.vertices = FALSE)
    }

    else if (type == "taskspecific") {
      ### ignore index
      if (0 %in% subID) {
        stop("please specify valid task number(s)")
      }
      if (is.null(subID)) {
        stop("please specify task number(s)")
      }
      if (!prod(subID %in% (1:K))) {
        stop("please specify valid task number(s)")
      }
      gadj = subgraph.edges(gadj, which(E(gadj)$weight %in% subID), delete.vertices = FALSE)

    }

    else if (type == "task") {
      if (!is.null(subID)) {
        if (!prod(subID %in% (0:K))) {
          stop("please specify valid task number(s)")
        }
        ### when subID = 0, gadj will be shared graph
        ### when subID = others, gadj will be graph for task with subID (including shared part)
        gadj = subgraph.edges(gadj, which(E(gadj)$weight %in% c(subID, K + 1)), delete.vertices = FALSE)
      }
      ### when subID is null, return all graphs
    }

    else if (type == "neighbour") {
      if (!prod(index %in% (1:vcount(gadj)))) {
        stop("please specify valid index number(s)")
      }

      gadj = subgraph.edges(gadj, unlist(incident_edges(gadj, index)) , delete.vertices = FALSE)
      if (neighbouroption == "task") {
        if (!is.null(subID)) {
          if (!prod(subID %in% (0:K))) {
            stop("please specify valid task number(s)")
          }
          gadj = subgraph.edges(gadj, which(E(gadj)$weight %in% c(subID, K + 1)), delete.vertices = FALSE)
        }
      }
      else if (neighbouroption == "taskspecific") {
        if (!prod(subID %in% (1:K))) {
          stop("please specify valid task number(s)")
        }
        gadj = subgraph.edges(gadj, which(E(gadj)$weight %in% subID), delete.vertices = FALSE)
      }
      else {
        stop("please specify a valid neighbouroption")
      }

    }

    else {
      stop("please specify a correct type")
    }

    return(gadj)
  }


### old method
if (FALSE) {
  return.fasjem <-
    function(x,
             option = "adjmatrix",
             type = "graph",
             subID = NULL,
             index = NULL,
             ...) {
      .env = "environment: namespace:fasjem"
      #UseMethod("plot")
      tmp = x
      x = list()
      p = dim(tmp[[1]])[1]
      if (type == "share") {
        x[[1]] = tmp[[1]] & tmp[[2]]
        for (i in 2:length(tmp)) {
          x[[1]] = x[[1]] & tmp[[i]]
        }
        x[[1]] = matrix(as.numeric(x[[1]]), p, p)
      }
      if (type == "sub") {
        temp = tmp[[1]] & tmp[[2]]
        for (i in 2:length(tmp)) {
          temp = temp & tmp[[i]]
        }
        temp = !temp
        temp = matrix(as.numeric(temp), p, p)
        x[[1]] = tmp[[subID]] * temp
      }
      if (type == "graph") {
        x = tmp
      }
      if (type == "neighbor") {
        id = matrix(0, p, p)
        id[index,] = rep(1, p)
        id[, index] = rep(1, p)
        for (i in 1:length(tmp)) {
          x[[i]] = tmp[[i]] * id
        }
      }
      K = length(x)
      adj = .make.adj.matrix(x)
      diag(adj) = 0
      if (option == "adjmatrix") {
        return (adj)
      }
      else if (option == "igraph") {
        gadj = graph.adjacency(adj, mode = "upper", weighted = TRUE)
        #weight the edges according to the classes they belong to
        E(gadj)$color = get.edge.attribute(gadj, "weight")
        return (gadj)
      }
      else {
        print("please specify option as either igraph or adjmatrix")
        return(NULL)
      }
    }
}

plot.fasjem <-
  function(fasjemresult,
           option = "2D",
           graphlabel = NULL,
           type = "task",
           neighbouroption = "task",
           subID = NULL,
           index = NULL,
           graphlayout = NULL,
           ...)
  {
    subID = unique(subID)
    index = unique(index)
    .env = "environment: namespace:fasjem"
    gadj = returngraph.fasjem(
      fasjemresult,
      type = type,
      neighbouroption = neighbouroption,
      subID = subID,
      index = index
    )

    graphlayout = .makelayout(gadj, option = option, graphlayout = graphlayout)

    ## make title according to user input
    title = .maketitle(
      type = type,
      subID = subID,
      index = index,
      graphlabel = graphlabel,
      neighbouroption = neighbouroption
    )

    if (option == "2D") {
      plot(
        gadj,
        layout = graphlayout,
        vertex.label.font = 2,
        vertex.shape = "none",
        vertex.label.color = "gray40",
        vertex.label = graphlabel,
        vertex.label.cex = .7,
        vertex.frame.color = "white",
        vertex.size = 10 ,
        main = title
      )

      legend(
        "topleft" ,
        legend = c(paste("task", c(
          1:length(fasjemresult)
        ), "specific"), "share"),
        col = categorical_pal(length(fasjemresult) + 1),
        pch = 16
      )

    }

    else if (option == "3D") {
      rglplot(
        gadj,
        layout = graphlayout,
        vertex.label.font = 2,
        vertex.shape = "none",
        vertex.label.color = "gray40",
        vertex.label = graphlabel,
        vertex.label.cex = .7,
        vertex.size = 10,
        vertex.frame.color = "white",
        main = title
      )
    }
    else if (option == "interactive") {
      tkplot(
        gadj,
        layout = graphlayout,
        vertex.label.font = 2,
        vertex.shape = "none",
        vertex.label.color = "gray40",
        vertex.label = graphlabel,
        vertex.label.cex = .7,
        vertex.size = 10,
        vertex.frame.color = "white",
        main = title
      )
    }
    else {
      stop("please specify a valid option")
    }

  }

### make adjacency matrix
.make.adj.matrix <-
  function(theta, separate = FALSE)
  {
    K = length(theta)
    adj = list()
    if (separate)
    {
      for (k in 1:K)
      {
        adj[[k]] = (abs(theta[[k]]) > 1e-5) * 1
      }
    }
    if (!separate)
    {
      adj = 0 * theta[[1]]
      for (k in 1:K)
      {
        adj = adj + (abs(theta[[k]]) > 1e-5) * 2 ^ (k - 1)
      }
    }
    return(adj)
  }

.maketitle <-
  function(type = "task",
           subID = NULL,
           index = NULL,
           neighbouroption = "task",
           graphlabel = NULL)
  {
    if (type == "share") {
      return ("Shared Graph")
    }

    if (type == "taskspecific") {
      temp = paste(as.character(subID), collapse = ", ")
      return (paste("Task", temp, "Specific Graph"))
    }

    if (type == "task") {
      if (is.null(subID)) {
        return ("All Graphs")
      }
      else {
        if (length(subID) == 1) {
          if (subID == 0) {
            return ("Shared Graph")
          }
          else{
            return (paste("Task", subID, "Graph"))
          }
        }
        else {
          if (0 %in% subID) {
            temp = subID[-(which(subID %in% 0))]

            return(paste("Task", paste(as.character(temp), collapse = ", ")), "Graph")
          }
          else {
            return (paste("Task", paste(
              as.character(subID), collapse = ", "
            ), "Graph"))
          }
        }
      }
    }

    if (type == "neighbour") {
      second = ""
      first = ""

      if (neighbouroption == "task") {
        if (length(subID) == 1) {
          if (subID == 0) {
            second = "on shared graph"
          }
          else {
            second = paste("on task",
                           paste(as.character(subID), collapse = ", "),
                           "graph")
          }
        }
        else {
          if (!is.null(subID)) {
            if (0 %in% subID) {
              temp = subID[-(which(subID %in% 0))]

              second = paste("on task",
                             paste(as.character(temp), collapse = ", "),
                             "graph")
            }
            else {
              second = paste("on task",
                             paste(as.character(subID), collapse = ", "),
                             "graph")
            }
          }
          else {
            second = "on all graphs"
          }
        }
      }
      else{
        second = paste("on task",
                       paste(as.character(subID), collapse = ", "),
                       "specific graph")
      }

      if (is.null(graphlabel) || is.na(graphlabel)) {
        first = paste("Zoom in at node", paste(as.character(index), collapse = ", "))
      }

      else {
        first = paste("Zoom in at node", paste(as.character(graphlabel[index]), collapse = ", "))
      }

      return (paste(first, second))
    }

  }

## helper function to create layout for graph
.makelayout <-
  function(x,
           option = "2D",
           graphlayout = NULL)
  {
    if (is.null(graphlayout)) {
      if (option == "2D" | option == "interactive") {
        graphlayout = layout_nicely(x, dim = 2)

      }
      if (option == "3D") {
        graphlayout = layout_nicely(x, dim = 3)
      }
    }
    return(graphlayout)
  }
