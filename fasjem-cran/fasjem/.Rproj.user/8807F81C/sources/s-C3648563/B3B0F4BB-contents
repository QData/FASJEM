#A simplex solver for linear programming problem in (N)SIMULE
.linprogSPar <- function(i, Sigma, lambda)
  {
    # num of p * N
    # pTimesN = nrow(Sigma)
    # num of p * (N + 1)
    # Get parameters
    q = ncol(Sigma)
    p = ncol(Sigma) - nrow(Sigma)
    N = nrow(Sigma) / p
    # Generate e_j
    e = rep(0, p * N)
    for(j in 1:N){
        e[i + (j - 1) * p] = 1
    }
    # linear programming solution
    f.obj = rep(1, 2 * q)
    con1 = cbind(-Sigma, +Sigma)
    b1 = lambda - e
    b2 =  lambda + e
    f.con = rbind(-diag(2 * q), con1, -con1)
    f.rhs = c(rep(0, 2 * q), b1, b2)
    f.dir = rep("<=", length(f.rhs))
    lp.out = lp("min", f.obj, f.con, f.dir, f.rhs)
    beta = lp.out$solution[1:q] - lp.out$solution[(q + 1):(2 * q)]
    if (lp.out$status == 2) warning("No feasible solution!  Try a larger tuning parameter!")
    return(beta)
}

# (N)SIMULE implementation
simule <- function(X, lambda, epsilon = 1, covType = "cov",parallel = FALSE )
  {

    if (is.data.frame(X[[1]])){
      for (i in 1:(length(X))){
        X[[i]] = as.matrix(X[[i]])
      }
    }

    #get number of tasks
    N = length(X)
    #get the cov/cor matrices
    if (isSymmetric(X[[1]]) == FALSE){
      try(if (covType %in% c("cov","kendall") == FALSE) stop("The cov/cor type you specifies is not include in this package. Please use your own function to obtain the list of cov/cor and use them as the input of simule()"))
      if (covType == "cov")
      {
        for (i in 1:N){
          X[[i]] = cov(X[[i]])
        }
      }
      if (covType == "kendall"){
        for(i in 1:N){
          X[[i]] = cor.fk(X[[i]])
        }
      }
    }
    # initialize the parameters
    Graphs = list()
    p = ncol(X[[1]])
    xt = matrix(0, (N + 1) * p, p)
    I = diag(1, p, p)
    Z = matrix(0, p, p)
    # generate the condition matrix A
    A = X[[1]]
    for(i in 2:N){
        A = cbind(A,Z)
    }
    A = cbind(A,(1/(epsilon * N))*X[[1]])
    for(i in 2:N){
        temp = Z
        for(j in 2:N){
            if (j == i){
                temp = cbind(temp,X[[i]])
            }
            else{
                temp = cbind(temp,Z)
            }
        }
        temp = cbind(temp, 1/(epsilon * N) * X[[i]])
        A = rbind(A, temp)
    }
    # define the function f for parallelization
    f = function(x) .linprogSPar(x, A, lambda)

    if(parallel == TRUE){ # parallel version
    	# number of cores to collect,
    	# default number is number cores in your machine - 1,
    	# you can set your own number by changing this line.
        no_cores = detectCores() - 1
        cl = makeCluster(no_cores)
        # declare variable and function names to the cluster
        clusterExport(cl, list("f", "A", "lambda", ".linprogSPar", "lp"), envir = environment())
        result = parLapply(cl, 1:p, f)
        #print('Done!')
        for (i in 1:p){
            xt[,i] = result[[i]]
        }
        stopCluster(cl)
    }else{ # single machine code
        for (i in 1 : p){
            xt[,i] = f(i)
            if (i %% 10 == 0){
                cat("=")
                if(i %% 100 == 0){
                    cat("+")
                }
            }
        }
        print("Done!")
    }

    for(i in 1:N){
    	# combine the results from each column. (\hat{\Omega}_{tot}^1)
        Graphs[[i]] = xt[(1 + (i-1) * p):(i * p),] + 1/(epsilon * N) * xt[(1 + N * p):((N + 1) * p),]
        # make it be symmetric
        for(j in 1:p){
            for(k in j:p){
                if (abs(Graphs[[i]][j,k]) < abs(Graphs[[i]][k,j])){
                    Graphs[[i]][j,k] = Graphs[[i]][j,k]
                    Graphs[[i]][k,j] = Graphs[[i]][j,k]
                }
                else{
                    Graphs[[i]][j,k] = Graphs[[i]][k,j]
                    Graphs[[i]][k,j] = Graphs[[i]][k,j]
                }
            }
        }
    }
    share = 1/(epsilon * N) * xt[(1 + N * p):((N + 1) * p),]
    for(j in 1:p){
      for(k in j:p){
        if (abs(share[j,k]) < abs(share[k,j])){
          share[j,k] = share[j,k]
          share[k,j] = share[j,k]
        }
        else{
          share[j,k] = share[k,j]
          share[k,j] = share[k,j]
        }
      }
    }
    out = list(Graphs = Graphs, share = share)
    class(out) = "simule"
    return(out)
}

## not yet implemented
plotmultiple.simule <- function(x)
{

}

## plot simule results acoording to user preferences
plot.simule <-
  function(x, option = "2D", graphlabel = NULL, type="graph", subID=NULL, index=NULL,
           graphlayout = NULL , ...)
  {
    .env = "environment: namespace:simule"

    ## if layout is not specified, use fruchterman reingold

    ## gadj is the igraph specified by user input
    gadj = return.simule(x, option = "igraph", type=type, subID=subID, index=index)

    graphlayout = .makelayout(gadj, option = option, graphlayout = graphlayout)

    ## make title according to user input
    title = .maketitle(type=type, subID=subID, index=index, graphlabel = graphlabel)

        if (option == "2D"){
          plot(gadj, layout = graphlayout,
               vertex.label.font=2,
               vertex.shape="none",
               vertex.label.color="gray40",
               vertex.label = graphlabel,
               vertex.label.cex=.7, vertex.frame.color="white", vertex.size = 10 ,main = title)

          if (type == "graph" && is.null(subID)){
            legend("topleft" , legend = c(paste("individual",c(1:length(x))), "share"),
                   col = categorical_pal(length(x)+1), pch = 16)
          }
        }

        if (option == "3D"){
          rglplot(gadj,layout = graphlayout,
                  vertex.label.font=2,
                  vertex.shape="none",
                  vertex.label.color="gray40",
                  vertex.label = graphlabel,
                  vertex.label.cex=.7, vertex.size = 10, vertex.frame.color="white", main = title)
        }
        if (option == "interactive"){
          tkplot(gadj,layout = graphlayout,
                 vertex.label.font=2,
                 vertex.shape="none",
                 vertex.label.color="gray40",
                 vertex.label = graphlabel,
                 vertex.label.cex=.7, vertex.size = 10, vertex.frame.color="white", main = title)
        }

    #  plot(gadj, vertex.frame.color="white",layout = graphlayout,
          # vertex.label = graphlabel, vertex.label.cex=3, vertex.size=1)
  }

# a function to return either adjacency matrix or igraph of type user specified (entire graph / shared / individual / neighbor (zoom into one node) )
return.simule <- function(x, option = "adjmatrix", type="graph", subID=NULL, index=NULL)
{
  .env = "environment: namespace:simule"
  #UseMethod("plot")
  tmp = x$Graphs
  Graphs = list()

  p = dim(tmp[[1]])[1]

  if (type == "share"){
    Graphs[[1]] = x$share
  }


  if (type == "sub"){
    if (!is.null(subID))
      {
      if (subID == 0){
        Graphs[[1]] = x$share
      }
      else {
        Graphs[[1]] = tmp[[subID]] - x$share
      }
    }
    else {
      print("Please specify subID")
      return(NA)
    }
  }



  if (type == "graph"){
    Graphs = tmp
  }

  ## can i make it zoom into multiple nodes
  if (type == "neighbor"){


    if (is.null(subID)){
    id = matrix(0,p,p)
    id[index,] = rep(1,p)
    id[,index] = rep(1,p)
    for (i in 1:length(tmp)){
      Graphs[[i]] = tmp[[i]] * id
    }
    }


    else {



      if (subID == 0){
      id = matrix(0,p,p)
      id[index,] = rep(1,p)
      id[,index] = rep(1,p)
      for (i in 1:length(tmp)){
        Graphs[[i]] = x$share * id
      }
      }



      else {
        id = matrix(0,p,p)
        id[index,] = rep(1,p)
        id[,index] = rep(1,p)
        for (i in 1:length(tmp)){
          Graphs[[i]] = (tmp[[subID]] - x$share) * id
        }
      }


    }
  }

  K=length(Graphs)
  adj = .make.adj.matrix(Graphs)
  diag(adj)=0

  if (option == "adjmatrix"){
    return(adj)
  }

  if (option == "igraph"){


  ### old code to
  #colnames(adj) <- name
  #rownames(adj) <- name
  #gadj = graph_from_adjacency_matrix(adj,mode="upper",weighted=TRUE, add.colnames = 'name')


  gadj = graph_from_adjacency_matrix(adj,mode="upper",weighted=TRUE)
  #print(get.edge.attribute(gadj,"weight"))
  E(gadj)$color = get.edge.attribute(gadj,"weight")
  return(gadj)
  }
}

# make adjacency matrix
.make.adj.matrix <-
  function(theta, separate=FALSE)
  {
    K = length(theta)
    adj = list()

    if(separate)
    {
      for(k in 1:K)
      {
        adj[[k]] = (abs(theta[[k]])>1e-5)*1
      }
    }

    if(!separate)
    {
      adj = 0*theta[[1]]
      for(k in 1:K)
      {
        adj = adj+(abs(theta[[k]])>1e-5)*2^(k-1)
      }
    }

    return(adj)
  }

## helper function to create title for graph
.maketitle <-
  function(type="graph", subID=NULL, index=NULL, graphlabel = NULL)
    {

    if (type == "share"){
      return ("Shared Graph")
    }

    if (type == "sub"){
      if (!is.null(subID)) {
        return (paste("Individual Graph",subID))
      }
      else {
        print("Please specify subID")
        return(NA)
      }
    }

    if (type == "graph"){
      return ("Entire Graph")
    }

    if (type == "neighbor"){


      if (is.null(graphlabel) || is.na(graphlabel)){
        temp = paste(as.character(index), collapse=", ")
        return (paste("Zoom in at node", temp))
      }

      else {
        temp = paste(as.character(graphlabel[index]), collapse=", ")
        return (paste("Zoom in at node", temp))
      }

    }

  }

## helper function to create layout for graph
.makelayout <-
  function(x, option = "2D", graphlayout = NULL)
    {
    if (is.null(graphlayout)) {
      if (option == "2D" | option == "interactive"){
        graphlayout = layout_nicely(x,dim=2)

      }
      if (option == "3D"){
        graphlayout = layout_nicely(x,dim=3)
      }
    }
    return(graphlayout)
  }
